/*
 * Company: ChowDSP
 * Effect Name: ChowCentaur
 * Description: A digital emulation of the public schematic for the Klon Centaur guitar pedal.
 *
 * This file was auto-generated by Aviate Audio Effect Creator for the Multiverse.
 */
#include <cmath>
#include "Aviate/EfxPrint.h"
#include "Aviate/LibBasicFunctions.h"
#include "AudioFilterBiquad.h"
#include "utility/dspinst.h"

#include "InputBuffer.h"
#include "PreAmpStage.h"
#include "AmpStage.h"
#include "ClippingStage.h"
#include "FF1Current.h"
#include "FeedForward2.h"
#include "SummingAmp.h"
#include "ToneControl.h"
#include "OutputBuffer.h"

#include "ChowCentaur.h"

using namespace Aviate;

namespace ChowDSP_ChowCentaur {

struct ChowCentaur::impl {

    InputBufferFloat      inputBufferFloat;
    PreAmpStageFloat      preAmpStageFloat;
    FF1CurrentFloat       ff1Float;
    AmpStageFloat         ampStageFloat;
    ClippingStageFloat    clippingStageFloat;
    FeedForward2Float     ff2Float;
    SummingAmpFloat       summingAmpFloat;
    ToneControlFloat      toneControlFloat;
    OutputBufferFloat     outputBufferFloat;

};

ChowCentaur::ChowCentaur()
: AudioStream(NUM_INPUTS, m_inputQueueArray)
{
    // perform any necessary class initialization here
    pimpl = new ChowCentaur::impl;

    pimpl->preAmpStageFloat.setGain(1.0f);
    pimpl->ampStageFloat.setGain(1.0f);
    pimpl->ff1Float.setPreAmp(&pimpl->preAmpStageFloat);
    pimpl->toneControlFloat.setTreble(0.4f);
    pimpl->outputBufferFloat.setLevel(0.5f);
}

ChowCentaur::~ChowCentaur()
{
    // perform any necessary clean up here, though destructors are not
    // called on the hardware, only in the simulator.
}

void ChowCentaur::update(void)
{
    audio_block_t *inputAudioBlock = receiveWritable(); // get the next block of input samples
    inputAudioBlock = m_basicInputCheck(inputAudioBlock, 0); // check for disable mode, bypass, or invalid inputs. Transmit to channel 0 in bypass
    if (!inputAudioBlock) { return; } // no further processing for this update() call

    // You must call m_updateInputPeak() before processing the audio
    m_updateInputPeak(inputAudioBlock);

    // float copies
    float bufferf[128];
    float ff1Outputf[128];
    float inputCopyf[128];

    arm_q15_to_float (inputAudioBlock->data, bufferf, AUDIO_SAMPLES_PER_BLOCK);  // buffer contains input
    // copy the fullscale input signal tot he input copy buffer, but then reduce the path to the preamp
    // stage by a factor of 10 to simulate or typical guitar pickup voltages. This was done to try to
    // get the signal to clean up a bit at lower volumes. It is admittedly a kluge to get usable gain
    // staging at the moment.
    //memcpy(inputCopyf, bufferf, AUDIO_SAMPLES_PER_BLOCK * sizeof(float));    // copy to bufferInput
    arm_scale_f32(bufferf, 0.5f, bufferf, AUDIO_SAMPLES_PER_BLOCK);  // assume lower guitar level than full scale
    memcpy(inputCopyf, bufferf, AUDIO_SAMPLES_PER_BLOCK * sizeof(float));    // copy to bufferInput

    // FLOAT PROCESSING
    // Call the inputBuffer
    if (m_modelinputbuf) pimpl->inputBufferFloat.update(bufferf, AUDIO_SAMPLES_PER_BLOCK);  // biquad
    pimpl->preAmpStageFloat.update(bufferf, AUDIO_SAMPLES_PER_BLOCK);
    pimpl->ampStageFloat.update(bufferf, AUDIO_SAMPLES_PER_BLOCK);     // biquad
    pimpl->clippingStageFloat.update(bufferf, AUDIO_SAMPLES_PER_BLOCK);  // Mixer 1

    pimpl->ff2Float.update(inputCopyf, AUDIO_SAMPLES_PER_BLOCK);  // Mixer 2
    pimpl->ff1Float.update(ff1Outputf, AUDIO_SAMPLES_PER_BLOCK);  // Mixer 0

    // Mixer
    for (unsigned idx=0; idx<AUDIO_SAMPLES_PER_BLOCK; idx++) {
        bufferf[idx] = bufferf[idx] + inputCopyf[idx] + ff1Outputf[idx];
    }

    pimpl->summingAmpFloat.update(bufferf, AUDIO_SAMPLES_PER_BLOCK);    // biquad
    arm_scale_f32(bufferf, 0.0005f, bufferf, AUDIO_SAMPLES_PER_BLOCK); // kluge -60 dB needed to prevent massive output level clipping
    pimpl->toneControlFloat.update(bufferf, AUDIO_SAMPLES_PER_BLOCK);   // biquad
    if (m_modeloutputbuf) pimpl->outputBufferFloat.update(bufferf, AUDIO_SAMPLES_PER_BLOCK);  // biquad
    arm_scale_f32(bufferf, m_volume, bufferf, AUDIO_SAMPLES_PER_BLOCK);
    arm_float_to_q15(bufferf, inputAudioBlock->data, AUDIO_SAMPLES_PER_BLOCK);

    m_updateOutputPeak(inputAudioBlock); // you must call m_upateOutputPeak() at the end of update() before transmit
    transmit(inputAudioBlock,0);
    release(inputAudioBlock);
}

void ChowCentaur::volume(float value)
{
    pimpl->outputBufferFloat.setLevel(value);
    float volDbValue = -40.0f + (value * 50.0f);  // remap the normalized value to represent -40dB to +10dB
    volumeDb(volDbValue);  // AudioEffectWrapper has built-in volume function in dB

    EFX_PRINT(Serial.printf("volume changed! Normalized value: %f  dB value: %f\n\r", value, volDbValue));
}

void ChowCentaur::gain(float value)
{
    // The linear gain puts all the useful gain too high, lets try a taper function!
    // y = a(b^x-1) where a=1/(b-1), b = (1/ym -1)^2, and ym controls log (>0.5), exp(<0.5), or linear(=0.5)
    static constexpr float ym = 0.8f;  // moderately logarithmic
    static constexpr float b = ((1.0f / ym) - 1.0f) * ((1.0f / ym) - 1.0f);
    static constexpr float a = 1.0f / (b - 1.0f);
    value = a * (std::pow(b,value) - 1.0f);
    m_gain = value;
    pimpl->preAmpStageFloat.setGain(m_gain);
    pimpl->ampStageFloat.setGain(m_gain);
    pimpl->ff2Float.setGain(m_gain);

    EFX_PRINT(Serial.printf("ChowCentaur::gain: %f\n\r", m_gain));
}

void ChowCentaur::treble(float value)
{
    m_treble = value;
    pimpl->toneControlFloat.setTreble(m_treble);

    EFX_PRINT(Serial.printf("ChowCentaur::treble: %f\n\r", m_treble));
}

void ChowCentaur::modelinputbuf(float value)
{
    m_modelinputbuf = value;
}

void ChowCentaur::modeloutputbuf(float value)
{
    m_modeloutputbuf = value;
}

}